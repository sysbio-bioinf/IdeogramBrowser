package ideogram.input;
import ideogram.AllParameters;
import ideogram.IProgressNotifier;
import ideogram.MainApp;
import ideogram.tree.Interval;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.Reader;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.swing.JOptionPane;

import util.FileFormatException;


/**
 * 
 * Reads Affymetrix .CNT files generated by the 
 * <a href="http://www.affymetrix.com/products/software/specific/cnat.affx">Chromosome Copy Number Analysis Tool (CNAT)</a>.
 * 
 * @author jkraus, m. schmid
 *
 */
public class AffymetrixCntReaderModel extends AbstractIdeogramDataModel
{	
	/**
	 * Singleton class creating new database identifiers for each data set.
	 * 
	 * @author mueller
	 *
	 */
	public static class DataSetIdentifier
	{
		private static DataSetIdentifier instance = new DataSetIdentifier();
		private long id;
		
		private DataSetIdentifier() 
		{ 
			id = 0;
		}
		
		public static DataSetIdentifier getInstance()
		{
			return instance;
		}
		
		public static long getID()
		{
			return ++getInstance().id;
		}
	}

	
	/*
	 * Affymetrix copy number record
	 */
	public class AffyCntRecord implements Comparable<AffyCntRecord>
	{
		public long dataset_id;
		public Locus locus = new Locus();
		public String probeSet;
		
		public float log2ratio;
		
		// Version 1.0 Values
		public float	loh;
		public float	gsa_cn;
		public float	gsa_pval;
		public float	spa_cn;
		public float	spa_pval;
		public float	cpa_pval;
		
		// Version 1.1. Values
		public float 	hmmmedianlog2ratio;
		public float	neglog10pvalue;
		public byte		chipnum;
		public byte		cnstate;
		
		// 1.1 LOH file
		public float	refHetRate;
		public float	lohProb;
		public float	retProb;
		//public char[] 	call = new char[2];
		public byte		lohState;
		
		// Version 1.1 additional paired Values
		/*public float	log2ratiomin,
						hmmmedianlog2ratiomin,
						cnstatemin,
						neglog10pvaluemin,
						log2ratiomax,
						hmmmedianlog2ratiomax,
						cnstatemax,
						neglog10pvaluemax;*/
		
		public AffyCntRecord()
		{
			dataset_id = 0;
			log2ratio = Float.NaN;
			probeSet = "<unknown>";
			
			// Version 1.0 init
			spa_cn = Float.NaN;
			spa_pval = Float.NaN; 
			gsa_cn = Float.NaN; 
			gsa_pval = Float.NaN;
			cpa_pval = Float.NaN;
			loh = Float.NaN;
			
			//Version 1.1. init
			hmmmedianlog2ratio = Float.NaN;
			cnstate = -1;
			neglog10pvalue = Float.NaN;
			chipnum = -1;
			
			// paired
			/*log2ratiomin = Float.NaN;
			hmmmedianlog2ratiomin = Float.NaN;
			cnstatemin = Float.NaN;
			neglog10pvaluemin = Float.NaN;
			log2ratiomax = Float.NaN;
			hmmmedianlog2ratiomax = Float.NaN;
			cnstatemax = Float.NaN;
			neglog10pvaluemax = Float.NaN;*/
			
			// 1.1 LOH
			refHetRate = Float.NaN;
			lohProb = Float.NaN;
			retProb = Float.NaN;
			//call[0]='?';
			//call[1]='?';
			lohState = -1;
		}
		
		public AffyCntRecord( long dataset_id )
		{
			this();
			this.dataset_id = dataset_id;
		}

		public String toString() 
		{
			StringBuffer buf = new StringBuffer();
	
			buf.append("Locus = " + locus.toString() + "\n");
			buf.append("markerName = " + probeSet + "\n");
			buf.append("log2ratio = " + log2ratio + "\n");
				
			// 1.0 specific
			if(!Float.isNaN(gsa_cn)) {
				buf.append("loh = " + loh + "\n");
				buf.append("gsa_cn = " + gsa_cn + "\n");
				buf.append("gsa_pval = " + gsa_pval + "\n");
				buf.append("spa_cn = " + spa_cn + "\n");
				buf.append("spa_pval = " + spa_pval + "\n");
			}
			
			// 1.1 specific
			if(!Float.isNaN(hmmmedianlog2ratio)) {
				buf.append("hmmmedianlog2ratio = " + hmmmedianlog2ratio + "\n");
				buf.append("cnstate = " + cnstate + "\n");
				 buf.append("neglog10pvalue = " + neglog10pvalue + "\n");
			}
			
		
			// paired
			/*if(!Float.isNaN(log2ratiomin)) buf.append("log2ratiomin = "+log2ratiomin+"\n");
			if(!Float.isNaN(hmmmedianlog2ratiomin)) buf.append("hmmmedianlog2ratiomin = "+hmmmedianlog2ratiomin+"\n");
			if(!Float.isNaN(cnstatemin)) buf.append("cnstatemin = "+cnstatemin+"\n");
			if(!Float.isNaN(neglog10pvaluemin)) buf.append("neglog10pvaluemin = "+neglog10pvaluemin+"\n");
			if(!Float.isNaN(log2ratiomax)) buf.append("log2ratiomax = "+log2ratiomax+"\n");
			if(!Float.isNaN(hmmmedianlog2ratiomax)) buf.append("hmmmedianlog2ratiomax = "+hmmmedianlog2ratiomax+"\n");
			if(!Float.isNaN(cnstatemax)) buf.append("cnstatemax = "+cnstatemax+"\n");
			if(!Float.isNaN(neglog10pvaluemax)) buf.append("neglog10pvaluemax = "+neglog10pvaluemax+"\n");*/
			
			// LOH
			if (!Float.isNaN(refHetRate)) {
				buf.append("RefHetRate = "+refHetRate+"\n");
			}
			if(!Float.isNaN(lohProb)) {
				buf.append("LohState = "+lohState+"\n");
				buf.append("LohProb = "+lohProb+"\n");
				buf.append("RetProb = "+retProb+"\n");
				//buf.append("call = "+call[0]+call[1]+"\n");
			}
			
			if(chipnum!=-1) {
				buf.append("chipnum = " + chipnum + "\n");
			}
			
			return buf.toString();
		}

		public int compareTo(AffyCntRecord o)
		{
			if (locus.equals(o.locus)) return probeSet.compareTo(o.probeSet); 
			else return locus.compareTo(o.locus);
		}
				
	}

	
	public enum FileVersion { UNKNOWN, V1_0, V1_1 };
	
	private enum State { SINGLE_CN, SINGLE_LOH, BOTH, FINISH_CN, FINISH_LOH };
	
	protected static final int	MAX_CHARACTERS = 4096;

	protected long 					dataset_id;
	protected TreeSet<AffyCntRecord> data;
	protected AffyCntRecord[] 		cache;
	protected boolean 				valid;			// valid state
	protected IProgressNotifier 	notifier;
	protected File					CNFile;
	protected File					LOHFile;
	protected Map<String, String>	header;
	protected Map<String, String>	headerLOH;
	protected FileVersion			version;
	
	// often used structures made global
	private LineNumberReader		inCN;
	private LineNumberReader		inLOH;
	
	// field indices
	int iProbeSet,
		iChromosome,
		iPosition,
		iLog2Ratio,
		// 1.0 field indices
		iLOH,
		iSPA_CN,
		iSPA_pVal,
		iGSA_CN,
		iGSA_pVal,
		iCPA_pVal,
		// 1.1 field idices
		iHmmMedianLog2Ratio,
		iCNState,
		iNegLog10PValue,
		iChipNum,
		iCall,
		iRefHetRate,
		iLohState,
		iLohProb,
		iRetProb,
		
		iProbeSetCN,
		iChromosomeCN,
		iPositionCN,
		iProbeSetLOH,
		iChromosomeLOH,
		iPositionLOH,
		iChipNumCN,
		iChipNumLOH;
	
	
	public enum Fields {
		ProbeSet,	Chromosome,		Position,	/*Call,*/ 
		SPA_CN,		SPA_pVal,		GSA_CN,		GSA_pVal,
		CPA_pVal, 	LOH,			Log2Ratio,
		/* 1.1 */ 
		HmmMedianLog2Ratio, 	CNState,
		NegLog10PValue, 		ChipNum,
		// 1.1 paired
		/*HmmMedianLog2RatioMin, 	HmmMedianLog2RatioMax,
		CNStateMin, 			CNStateMax,
		Log2RatioMin, 			Log2RatioMax,
		NegLog10PValueMin, 		NegLog10PValueMax,*/
		// 1.1 LOH
		RefHetRate, LohState, LohProb, RetProb };

    public AffymetrixCntReaderModel() 
    {
        super();
        
        dataset_id = 0;
        data = new TreeSet<AffyCntRecord>();
        cache = null;
		valid = false;
		notifier = null;
		CNFile = null;
		LOHFile = null;
		header = null;
    }
    
    public void setNotifier( IProgressNotifier notifier )
    {
    	this.notifier = notifier;
    }
	
	/**
	 * Read "Affymetrix Copy Number Analysis Tool file" format.
	 *   
	 * @param file the *cnt file
	 * @throws FileFormatException 
	 * @throws IOException
	 */
	public void loadFromFile(File file)	throws IOException, FileFormatException
	{
		clear();
		this.CNFile = file;
		this.LOHFile = null;
		FileReader fr = new FileReader(file);
		readElements(fr);
		fr = null;
		fireChangeEvent();
	}
	
	/**
	 * Read "Affymetrix Copy Number Analysis Tool file" format.
	 *   
	 * @param file the *.cn.cnt file
	 * @param file the *.loh.cnt file
	 * @throws FileFormatException 
	 * @throws IOException 
	 */
	public void loadFromFile(File CNFile, File LOHFile)	throws IOException, FileFormatException
	{
		clear();
		this.CNFile = CNFile;
		this.LOHFile = LOHFile;
		FileReader fr = new FileReader(CNFile);
		FileReader fr2 = new FileReader(LOHFile);
		readElements(fr, fr2);
		fr=null;
		fr2=null;
		fireChangeEvent();
	}
	
	
	public void clear()
	{    
		data.clear();
		
		valid = false;
		CNFile= null;
		LOHFile = null;
		header = null;
        //cache = null;
	}
    
    public boolean isValid()
    {
        return valid;
    }
    
    /**
     * Finds a section "["+sectionName+"]"
     * @param reader
     * @param section
     * @return
     * @throws IOException
     */
    public boolean expectSection(LineNumberReader in, String sectionName) throws IOException
    {
    	in.mark(MAX_CHARACTERS);
   		String line = in.readLine();
		line = line.trim();
		if( line.equalsIgnoreCase("["+sectionName+"]") )
		{
			return true;
		}
    	in.reset();
    	return false;
    }
    
    
    /**
     * Reads the affymetrix CNT file header.
     * 
     * @param reader
     * @return
     * @throws IOException
     * @throws FileFormatException 
     */
    public Map<String,String> readHeader(LineNumberReader in) throws IOException, FileFormatException
    {   	
    	if( !expectSection(in,"Header") )
    		throw new FileFormatException("CNT file format error: missing [Header] section");
    
       	Map<String,String> header = new TreeMap<String,String>();
        
    	while( in.ready() )
    	{
    		in.mark(MAX_CHARACTERS);
    		String line = in.readLine();
			line = line.trim();
			
			if( line.length() == 0 )
				continue;
			
			if( line.startsWith("[") && line.endsWith("]") )
			{
				in.reset();
				break;
			}
			
			String v[] = line.split("=");
//			if( v.length != 2 )
//				throw new FileFormatException("Illegal [Header] entry in CNT file at line "+in.getLineNumber()+" : \n'"+line+"'");
			header.put(v[0], v[1]);
    	}
    	
    	return header;
    }
    
    
    /**
     * Reads an Affymetrix CNT ColumnName record from the given reader.
     * The stream is NOT reset.
     * 
     * @param reader
     * @return A Map with ColumnName -> ColumnIndex
     * @throws IOException
     * @throws FileFormatException 
     */
    public Map<String,Integer> readColumnNames(LineNumberReader in) throws IOException, FileFormatException
    {
    	if( ! expectSection(in, "ColumnName") )
    	{
    		throw new FileFormatException("CNT file format error: missing [ColumnName] section");
    	}
    	
    	String[] v = in.readLine().split("\t");
    	HashMap<String,Integer> ret = new HashMap<String,Integer>();
    	
    	for( int i=0; i<v.length; ++i )
    		ret.put(v[i], i);
    	return ret;
    }
    
    
	/**
	 * Reads a copy number list from a file.
	 * 
	 * @param reader
	 * @throws FileFormatException 
	 * @throws IOException 
	 * @throws IOException
	 * @throws FileFormatException
	 */   
        
	protected  void readElements(Reader filereader) throws IOException, FileFormatException {
			
		invalidate();
		
		inCN = new LineNumberReader( filereader );
		
		dataset_id = DataSetIdentifier.getID();		

		// [Header] section
		header = readHeader(inCN);
		String val;
		
		val = header.get("Version");
		
		// set file version
		if (val.equals("1.0")) version = FileVersion.V1_0;
		else if (val.equals("1.1")) version = FileVersion.V1_1;
		else version = FileVersion.UNKNOWN;
		
		
		if( val == null )
			throw new FileFormatException("CNT file format error: Version not found in [Header] section");
		if( val.compareTo("1.0") != 0 && val.compareTo("1.1") != 0)
		{
			// This is a point where LISP condition/restart handlers would succeed as this type of error
			// cannot be handled at this point.
			int res = JOptionPane.showConfirmDialog(null, "CNT file format is of unknown version '"+val+"' Proceed anyway?");
			if( res != JOptionPane.YES_OPTION )
				throw new FileFormatException("Action aborted: Unkown CNT file format version '"+val+"'");
		}

		int num_columns = -1;
		
		val = header.get("NumberDataColumns");
		if( val != null )
		{
			try {
				num_columns = Integer.parseInt(val);
			}
			catch( NumberFormatException e )
			{
				MainApp.getLogger().throwing(getClass().getName(),"readElements", e);
				throw new FileFormatException("CNT file format error: illegal value for [Header] entry 'NumberDataColumns'");
			}
		}
		
		//long num_rows = -1;
		/*val = header.get("NumberDataRows");
		if( val != null )
		{
			try {
				num_rows = Long.parseLong(val);
			}
			catch( NumberFormatException e )
			{
				MainApp.getLogger().throwing(getClass().getName(),"readElements", e);
				throw new FileFormatException("CNT file format error: illegal value for [Header] entry 'NumberDataRows'");
			}
		}*/
		
		// [ColumnName] section
		Map<String, Integer> col = readColumnNames(inCN);

		// check if desired fields are present
		LinkedList<Fields> requiredFields = new LinkedList<Fields>();
		requiredFields.add(Fields.ProbeSet);
		requiredFields.add(Fields.Chromosome);
		requiredFields.add(Fields.Position);

		if (version.equals(FileVersion.V1_0)) {
			
			requiredFields.add(Fields.Log2Ratio);
			requiredFields.add(Fields.SPA_CN);
			requiredFields.add(Fields.SPA_pVal);
			requiredFields.add(Fields.LOH);

		}
		else {					// Version 1.1 or unknown version

			val = header.get("Workflow");

			if( val == null ) {
				throw new FileFormatException("CNT file format error: Workflow entry missing");
			} else if (val == "paired-copy-number" || val == "unpaired-copy-number") {
				requiredFields.add(Fields.Log2Ratio);
				requiredFields.add(Fields.HmmMedianLog2Ratio);
				requiredFields.add(Fields.CNState);
				requiredFields.add(Fields.NegLog10PValue);
			}
			/*if (val == "paired-copy-number") {			
				requiredFields.add(Fields.Log2RatioMin);
				requiredFields.add(Fields.HmmMedianLog2RatioMin);
				requiredFields.add(Fields.CNStateMin);
				requiredFields.add(Fields.NegLog10PValueMin);
				requiredFields.add(Fields.Log2RatioMax);
				requiredFields.add(Fields.HmmMedianLog2RatioMax);
				requiredFields.add(Fields.CNStateMax);
				requiredFields.add(Fields.NegLog10PValueMax);
			}*/ else if (val == "unpaired-LOH") {
				//requiredFields.add(Fields.Call);
				//requiredFields.add(Fields.RefHetRate);
				requiredFields.add(Fields.LohState);
				requiredFields.add(Fields.Log2Ratio);
				requiredFields.add(Fields.LohProb);
				requiredFields.add(Fields.RetProb);
			}
			requiredFields.add(Fields.ChipNum);	
		}
		
		for (Fields f : requiredFields) {
			if (!col.containsKey(f.name()))
				throw new FileFormatException("Missing field '" + f.name()
						+ "' in CNT file!");
		}
			

		// find field indices
		iProbeSet = getFieldIndex(col, Fields.ProbeSet);
		iChromosome = getFieldIndex(col, Fields.Chromosome);
		iPosition = getFieldIndex(col, Fields.Position);
		iLog2Ratio = getFieldIndex(col,	Fields.Log2Ratio);
		iLOH = getFieldIndex(col, Fields.LOH);
		iSPA_CN = getFieldIndex(col, Fields.SPA_CN);
		iSPA_pVal = getFieldIndex(col,Fields.SPA_pVal);
		iGSA_CN = getFieldIndex(col,Fields.GSA_CN);
		iGSA_pVal = getFieldIndex(col,Fields.GSA_pVal);
		iCPA_pVal = getFieldIndex(col,Fields.CPA_pVal);

		// 1.1 specific fields
		iHmmMedianLog2Ratio = getFieldIndex(col, Fields.HmmMedianLog2Ratio);
		iCNState 	= getFieldIndex(col, Fields.CNState);
		iNegLog10PValue = getFieldIndex(col, Fields.NegLog10PValue);
		iChipNum	= getFieldIndex(col, Fields.ChipNum);
		
		// 1.1 paired field indices
		/*int iLog2RatioMin = getFieldIndex(col, Fields.Log2RatioMin),
			iLog2RatioMax = getFieldIndex(col, Fields.Log2RatioMax),
			iHmmMedianLog2RatioMin = getFieldIndex(col, Fields.HmmMedianLog2RatioMin),
			iHmmMedianLog2RatioMax = getFieldIndex(col, Fields.HmmMedianLog2RatioMax),
			iNegLog10PValueMin = getFieldIndex(col, Fields.NegLog10PValueMin),
			iNegLog10PValueMax = getFieldIndex(col, Fields.NegLog10PValueMax),
			iCNStateMin = getFieldIndex(col, Fields.CNStateMin),
			iCNStateMax = getFieldIndex(col, Fields.CNStateMax);		*/
		
		// 1.1 LOH
		//iCall = getFieldIndex(col,Fields.Call);
		iRefHetRate = getFieldIndex(col,Fields.RefHetRate);
		iLohState = getFieldIndex(col,Fields.LohState);
		iLohProb = getFieldIndex(col,Fields.LohProb);
		iRetProb = getFieldIndex(col,Fields.RetProb);
		
		// [Data] section
		if (!expectSection(inCN, "Data"))
			new FileFormatException(
					"CNT file format exception: [Data] section not found!");
		if (num_columns < 0) {
			num_columns = col.size();
		} else {
			if (num_columns != col.size())
				throw new FileFormatException(
						"Wrong number of columns! Inconsistency of [ColumnName] section with NumberDataColumns value in [Header] section!");
		}
		
		Byte chr;
		AffyCntRecord record;
		
		while (inCN.ready()) {
			String line = inCN.readLine();
			line = line.trim();
			
			if (line.length() == 0)	continue;
			
			String v[] = line.split("\t");
			
			if (v.length != num_columns)
				throw new FileFormatException(
						"CNT file format error at line "
									+ inCN.getLineNumber()
									+ " wrong number of columns (!="
									+ num_columns + ")");

				record = new AffyCntRecord(dataset_id);
				try {
					if (iProbeSet >= 0) {
						record.probeSet = v[iProbeSet];
					}
					if (iChromosome >= 0) {
						chr = 0;
						if(v[iChromosome].equalsIgnoreCase("X")) {
							chr = 23;
						} else if (v[iChromosome].equalsIgnoreCase("Y")) {
							chr = 24;
						} else {
							try {
								chr = Byte.parseByte(v[iChromosome]);
							} catch (NumberFormatException e) {
								//System.out.println("wrong chr in line "+in.getLineNumber());
							}
						}
						record.locus.chromosome = chr;
						if (record.locus.chromosome == 0) {
							continue;
						}
					}
					if (iPosition >= 0) {
						record.locus.setPosition(Long.parseLong(v[iPosition]));
					}
					if (iLOH >= 0){
						record.loh = Float.parseFloat(v[iLOH]);
					}
					if (iLog2Ratio >= 0){
						record.log2ratio = Float.parseFloat(v[iLog2Ratio]);
					}
					
					if (version == FileVersion.V1_0) {
						if (iSPA_CN >= 0){
							record.spa_cn = Float.parseFloat(v[iSPA_CN]);
						}
						if (iSPA_pVal >= 0){
							record.spa_pval = Float.parseFloat(v[iSPA_pVal]);
						}
						if (iGSA_CN >= 0){
							record.gsa_cn = Float.parseFloat(v[iGSA_CN]);
						}
						if (iGSA_pVal >= 0){
							record.gsa_pval = Float.parseFloat(v[iGSA_pVal]);
						}
						if (iCPA_pVal >= 0){
							record.cpa_pval = Float.parseFloat(v[iCPA_pVal]);
						}
					}
					else {		// Version 1.1
						
						if( iHmmMedianLog2Ratio >= 0 ) {
							record.hmmmedianlog2ratio = Float.parseFloat(v[iHmmMedianLog2Ratio]);
						}
						if( iCNState >= 0 ) {
							record.cnstate = Byte.parseByte(v[iCNState]);	
						}
						if( iNegLog10PValue >= 0 ) {
							record.neglog10pvalue = Float.parseFloat(v[iNegLog10PValue]);
						}
						if( iChipNum >= 0 ) {
							record.chipnum = Byte.parseByte(v[iChipNum]);
						}
					
						// 1.1 paired
						/*if (iLog2RatioMin >= 0)	record.log2ratiomin = parse(v[iLog2RatioMin]);
						if (iLog2RatioMax >= 0)	record.log2ratiomax = parse(v[iLog2RatioMax]);
						if (iHmmMedianLog2RatioMin >= 0) record.hmmmedianlog2ratiomin = parse(v[iHmmMedianLog2RatioMin]);
						if (iHmmMedianLog2RatioMax >= 0) record.hmmmedianlog2ratiomax = parse(v[iHmmMedianLog2RatioMax]);
						if (iNegLog10PValueMin >= 0) record.neglog10pvaluemin = parse(v[iNegLog10PValueMin]);
						if (iNegLog10PValueMax >= 0) record.neglog10pvaluemax = parse(v[iNegLog10PValueMax]);
						if (iCNStateMin >= 0) record.cnstatemin = parse(v[iCNStateMin]);
						if (iCNStateMax >= 0) record.cnstatemax = parse(v[iCNStateMax]);*/
					
						// 1.1 LOH
						//if (iCall >= 0) {
						//	record.call = v[iCall].toCharArray();
						//}
						if (iRefHetRate >= 0) {
							record.refHetRate = Float.parseFloat(v[iRefHetRate]);
						}
						if (iLohState >= 0) {
							record.lohState = Byte.parseByte(v[iLohState]);
						}
						if (iLohProb >= 0) {
							record.lohProb = Float.parseFloat(v[iLohProb]);
						}
						if (iRetProb >= 0) {
							record.retProb = Float.parseFloat(v[iRetProb]);
						}
						
					}
					
					
					// /
					//if (record.cnstate==0) System.out.println(record.toString());
				
				} catch (NumberFormatException e) {
					MainApp.getLogger().throwing(getClass().getName(),
							"readElements", e);
					throw new FileFormatException(
							"CNT file format error at line "
									+ inCN.getLineNumber()
									+ " illegal field value");
				} catch (Exception e) {
					MainApp.getLogger().throwing(getClass().getName(),
							"readElements", e);
					throw new FileFormatException(
							"Exception while parsing CNT file entry at line "
									+ inCN.getLineNumber() + "NEWLINE"
									+ e.getLocalizedMessage());
				}

				if (record.locus.chromosome > 0) { // more validity checks
													// here??
					data.add(record);
				}

				/*if (notifier != null) {
					// notify progress indicator
					int line_number = in.getLineNumber();
					if (line_number % 100 == 0) {
						if (num_rows > 0) {
							notifier
									.setText("import "
											+ Math
													.round((100.0 * (double) line_number / num_rows))
											+ "%");
						} else {
							notifier.setText("import " + (line_number / 1000)
									+ "k");
							}
						}
					}*/
		}
	}
	
	protected void readElements(Reader fileReaderCN, Reader fileReaderLOH) throws IOException, FileFormatException {
		
		invalidate();
		
		inCN = new LineNumberReader( fileReaderCN );
		inLOH = new LineNumberReader( fileReaderLOH );

		dataset_id = DataSetIdentifier.getID();		

		// [Header] section
		header = readHeader(inCN);
		headerLOH = readHeader(inLOH);
		
		String valCN, valLOH;
		
		valCN = header.get("Version");
		valLOH = headerLOH.get("Version");
		
		// set file version
		if (valCN.equals("1.1")) version = FileVersion.V1_1;
		else if(valCN.equals("1.0")) version = FileVersion.V1_0;
		else version = FileVersion.UNKNOWN;
		
		if( valCN == null )
			throw new FileFormatException("CNT file format error: Version not found in [Header] section");
		if( valCN.compareTo("1.1") != 0 && valCN.compareTo("1.1") != 0)
		{
			int res = JOptionPane.showConfirmDialog(null, "CNT and LOH file format is of unknown version ('"+valCN+"' and '"+valLOH+"'). Proceed anyway?");
			if( res != JOptionPane.YES_OPTION )
				throw new FileFormatException("Action aborted: Unkown CNT file format version '"+valCN+"'");
		}
		
		// check if same sample
		valCN = header.get("SampleName");
		valLOH = headerLOH.get("SampleName");
		if(!valCN.equals(valLOH)) throw new FileFormatException("Action aborted: CN and LOH file are not from the same sample.");

		
		int num_columns_CN = -1;
		int num_columns_LOH = -1;
		
		valCN = header.get("NumberDataColumns");
		valLOH = headerLOH.get("NumberDataColumns");
		

		
		try {
			num_columns_CN = Integer.parseInt(valCN);
		}
		catch( NumberFormatException e )
		{
			MainApp.getLogger().throwing(getClass().getName(),"readElements", e);
			throw new FileFormatException("CNT file format error: illegal value for [Header] entry 'NumberDataColumns' in CN File");
		}
		
		if( valLOH != null)
		{
			try {
				num_columns_LOH = Integer.parseInt(valLOH);
			}
				catch( NumberFormatException e )
			{
				MainApp.getLogger().throwing(getClass().getName(),"readElements", e);
				throw new FileFormatException("CNT file format error: illegal value for [Header] entry 'NumberDataColumns' in LOH File");
			}
		}
		
		
		
		/*
		 * long num_rows_CN = -1; long num_rows_LOH = -1;
		 */
		/*
		 * valCN = header.get("NumberDataRows"); valLOH =
		 * headerLOH.get("NumberDataRows");
		 */
		/*
		 * if( valCN != null ) { try { num_rows_CN = Long.parseLong(valCN); }
		 * catch( NumberFormatException e ) {
		 * MainApp.getLogger().throwing(getClass().getName(),"readElements", e);
		 * throw new FileFormatException("CNT file format error: illegal value
		 * for [Header] entry 'NumberDataRows' in CN File"); } } if( valLOH !=
		 * null ) { try { num_rows_LOH = Long.parseLong(valLOH); } catch(
		 * NumberFormatException e ) {
		 * MainApp.getLogger().throwing(getClass().getName(),"readElements", e);
		 * throw new FileFormatException("CNT file format error: illegal value
		 * for [Header] entry 'NumberDataRows' in LOH File"); } }
		 */
				
		// [ColumnName] section for CN file
		Map<String, Integer> colCN = readColumnNames(inCN);
		
		// [ColumnName] section for LOH file
		Map<String, Integer> colLOH = readColumnNames(inLOH);

		// check if desired fields are present
		LinkedList<Fields> requiredFieldsCN = new LinkedList<Fields>();
		LinkedList<Fields> requiredFieldsLOH = new LinkedList<Fields>();
		
		requiredFieldsCN.add(Fields.ProbeSet);
		requiredFieldsCN.add(Fields.Chromosome);
		requiredFieldsCN.add(Fields.Position);
		requiredFieldsLOH.add(Fields.ProbeSet);
		requiredFieldsLOH.add(Fields.Chromosome);
		requiredFieldsLOH.add(Fields.Position);

		valCN = header.get("Workflow");
		valLOH = headerLOH.get("Workflow");
			
		// boolean paired = false;

		if( valCN == null ) {
			throw new FileFormatException("CNT file format error: Workflow entry missing");
		}
		if (valCN.equals("paired-copy-number") || valCN.equals("unpaired-copy-number")) {
			requiredFieldsCN.add(Fields.Log2Ratio);
			requiredFieldsCN.add(Fields.HmmMedianLog2Ratio);
			requiredFieldsCN.add(Fields.CNState);
			requiredFieldsCN.add(Fields.NegLog10PValue);
		}
		/*
		 * if (valCN.equals("paired-copy-number")) { paired = true;
		 * requiredFieldsCN.add(Fields.Log2RatioMin);
		 * requiredFieldsCN.add(Fields.HmmMedianLog2RatioMin);
		 * requiredFieldsCN.add(Fields.CNStateMin);
		 * requiredFieldsCN.add(Fields.NegLog10PValueMin);
		 * requiredFieldsCN.add(Fields.Log2RatioMax);
		 * requiredFieldsCN.add(Fields.HmmMedianLog2RatioMax);
		 * requiredFieldsCN.add(Fields.CNStateMax);
		 * requiredFieldsCN.add(Fields.NegLog10PValueMax); }
		 */
		
		// requiredFieldsLOH.add(Fields.Call);
		// requiredFieldsLOH.add(Fields.RefHetRate);
		requiredFieldsLOH.add(Fields.LohState);
		requiredFieldsLOH.add(Fields.LohProb);
		requiredFieldsLOH.add(Fields.RetProb);
		
		requiredFieldsCN.add(Fields.ChipNum);	
		requiredFieldsLOH.add(Fields.ChipNum);
	
	
		for (Fields f : requiredFieldsCN) {
			if (!colCN.containsKey(f.name())) {
				throw new FileFormatException("Missing field '" + f.name()
					+ "' in .CN.CNT file!");
			}
		}
		for (Fields f : requiredFieldsLOH) {
			if (!colLOH.containsKey(f.name())) {
				throw new FileFormatException("Missing field '" + f.name()
						+ "' in .LOH.CNT file!");
			}
		}	

		// find field indices
		iProbeSetCN			= getFieldIndex(colCN, Fields.ProbeSet);
		iChromosomeCN 		= getFieldIndex(colCN, Fields.Chromosome);
		iPositionCN 		= getFieldIndex(colCN, Fields.Position);
		iLog2Ratio 			= getFieldIndex(colCN,	Fields.Log2Ratio);
		iProbeSetLOH 		= getFieldIndex(colLOH, Fields.ProbeSet);
		iChromosomeLOH 		= getFieldIndex(colLOH, Fields.Chromosome);
		iPositionLOH 		= getFieldIndex(colLOH, Fields.Position);

		iHmmMedianLog2Ratio = getFieldIndex(colCN, Fields.HmmMedianLog2Ratio);
		iCNState 			= getFieldIndex(colCN, Fields.CNState);
		iNegLog10PValue 	= getFieldIndex(colCN, Fields.NegLog10PValue);
		iChipNumCN			= getFieldIndex(colCN, Fields.ChipNum);
		iChipNumLOH			= getFieldIndex(colLOH, Fields.ChipNum);
		
		// 1.1 paired field indices
		/*
		 * int iLog2RatioMin = getFieldIndex(colCN, Fields.Log2RatioMin),
		 * iLog2RatioMax = getFieldIndex(colCN, Fields.Log2RatioMax),
		 * iHmmMedianLog2RatioMin = getFieldIndex(colCN,
		 * Fields.HmmMedianLog2RatioMin), iHmmMedianLog2RatioMax =
		 * getFieldIndex(colCN, Fields.HmmMedianLog2RatioMax),
		 * iNegLog10PValueMin = getFieldIndex(colCN, Fields.NegLog10PValueMin),
		 * iNegLog10PValueMax = getFieldIndex(colCN, Fields.NegLog10PValueMax),
		 * iCNStateMin = getFieldIndex(colCN, Fields.CNStateMin), iCNStateMax =
		 * getFieldIndex(colCN, Fields.CNStateMax);
		 */	
		
		// 1.1 LOH
		// iCall = getFieldIndex(colLOH,Fields.Call);
		iRefHetRate 			= getFieldIndex(colLOH,Fields.RefHetRate);
		iLohState 				= getFieldIndex(colLOH,Fields.LohState);
		iLohProb 				= getFieldIndex(colLOH,Fields.LohProb);
		iRetProb 				= getFieldIndex(colLOH,Fields.RetProb);
		
		// [Data] section
		if (!expectSection(inCN, "Data")) {
			new FileFormatException(
					"CNT file format exception: [Data] section not found!");
		}
		if (!expectSection(inLOH, "Data")) {
			new FileFormatException(
					"CNT file format exception: [Data] section not found!");
		}
		
		if (num_columns_CN < 0) {
			num_columns_CN = colCN.size();
		} else {
			if (num_columns_CN != colCN.size()) {
				throw new FileFormatException(
						"Wrong number of columns! Inconsistency of [ColumnName] section with NumberDataColumns value in [Header] section for CN File!");
			}
		}
		if (num_columns_LOH < 0) {
			num_columns_LOH = colLOH.size();
		} else {
			if (num_columns_LOH != colLOH.size()) {
				throw new FileFormatException(
						"Wrong number of columns! Inconsistency of [ColumnName] section with NumberDataColumns value in [Header] section for LOH File!");
			}
		}

		// if some entry is missing, this variable is set
		State state = State.BOTH;
		
		// last read lines in CN and LOH file
		String lineCN = null;
		String lineLOH = null;
		// last read elements from these lines
		String v1[] = null;
		String v2[] = null;
		
		Byte chrCN;
		Byte chrLOH;
		
		Locus locCN;
		Locus locLOH;
		
		String probeSetCN;
		String probeSetLOH;
		
		AffyCntRecord record;
		
		while (inCN.ready() || inLOH.ready()) {

			// CN file EOF, finish LOH file
			if(!inCN.ready()) state = State.FINISH_LOH;
			// LOH file EOF, finish CN file
			if(!inLOH.ready()) state = State.FINISH_CN;
			
			if(state == State.SINGLE_CN || state == State.FINISH_CN) {
				// single cn used last time, only read next CN-line
				lineCN = inCN.readLine().trim();
				while (lineCN.length() == 0) lineCN = inCN.readLine().trim();

				v1 = lineCN.split("\t");
			} else if (state == State.SINGLE_LOH || state == State.FINISH_LOH) {
				// single loh used last time, only read next loh-line
				lineLOH = inLOH.readLine().trim();
				while (lineLOH.length() == 0) lineLOH = inLOH.readLine().trim();
				v2 = lineLOH.split("\t");
			} else {
				// else: both read, read 2 new lines
				lineCN = inCN.readLine().trim();
				lineLOH = inLOH.readLine().trim();
				while (lineCN.length() == 0) lineCN = inCN.readLine().trim();
				while (lineLOH.length() == 0) lineLOH = inLOH.readLine().trim();
				v1 = lineCN.split("\t");
				v2 = lineLOH.split("\t");
			}
			
			if (v1.length != num_columns_CN) {
				throw new FileFormatException(
						"CN.CNT file format error at line "
									+ inCN.getLineNumber()
									+ " wrong number of columns (!="
									+ num_columns_CN + ")");
			}
			if (v2.length != num_columns_LOH) {
				throw new FileFormatException(
						"LOH.CNT file format error at line "
									+ inLOH.getLineNumber()
									+ " wrong number of columns (!="
									+ num_columns_LOH + ")");
			}
			

			record = new AffyCntRecord(dataset_id);
			try {
				locCN = new Locus();
				locLOH = new Locus();
					
				if((iPositionCN >= 0 && iPositionLOH >= 0) && (iProbeSetCN >= 0 && iProbeSetLOH >= 0) && (iChromosomeCN >= 0 && iChromosomeLOH >=0 )) {
					probeSetCN = v1[iProbeSetCN];
					locCN.setPosition(Long.parseLong(v1[iPositionCN]));
					chrCN = 0;
					if(v1[iChromosomeCN].equalsIgnoreCase("X")) {
						chrCN = 23;
					} else if (v1[iChromosomeCN].equalsIgnoreCase("Y")) {
						chrCN = 24;
					} else {
						try {
							chrCN = Byte.parseByte(v1[iChromosomeCN]);
						} catch (NumberFormatException e) {
							// System.out.println("falsches chr in cn line
							// "+inCN.getLineNumber());
						}
					}
					locCN.chromosome = chrCN;
						
					probeSetLOH = v2[iProbeSetLOH];
					locLOH.setPosition(Long.parseLong(v2[iPositionLOH]));
		
					chrLOH = 0;
					if(v2[iChromosomeLOH].equalsIgnoreCase("X")) {
						chrLOH = 23;
					} else if (v2[iChromosomeLOH].equalsIgnoreCase("Y")) {
						chrLOH = 24;
					} else {
						try {
							chrLOH = Byte.parseByte(v2[iChromosomeLOH]);
						} catch (NumberFormatException e) {
							// System.out.println("falsches chr in loh line
							// "+inLOH.getLineNumber());
						}
					}
					locLOH.chromosome = chrLOH;
					
					if (state != State.FINISH_CN && state != State.FINISH_LOH) {
						if (locCN.compareTo(locLOH) == 0 && probeSetCN.equals(probeSetLOH)) {
							// read both to one record
							state = State.BOTH;
						} else if (locCN.compareTo(locLOH) < 0) { // locCN
																		// <
																		// locLOH
							// only read CN (loh missing)
							state = State.SINGLE_CN;
						} else if (locCN.compareTo(locLOH) > 0) { // locCN
																		// >																		// locLOH
								// only read LOH (cn missing)
							state = State.SINGLE_LOH;
						} else throw new FileFormatException("different snps on same location");
					}
				} else {
					throw new FileFormatException(
						"Position, Chromosome or ProbeSet field missing in CN or LOH file.");
					}
					if ( state == State.SINGLE_CN || state == State.BOTH || state == State.FINISH_CN) {
						record.probeSet = probeSetCN;
						record.locus = locCN;
						if (iLog2Ratio >= 0)
							record.log2ratio = Float.parseFloat(v1[iLog2Ratio]);
						if (iHmmMedianLog2Ratio >= 0)
							record.hmmmedianlog2ratio = Float.parseFloat(v1[iHmmMedianLog2Ratio]);
						if (iCNState >= 0)
							record.cnstate = Byte.parseByte(v1[iCNState]);
						if (iNegLog10PValue >= 0)
							record.neglog10pvalue = Float.parseFloat(v1[iNegLog10PValue]);
						if (iChipNumCN >= 0)
							record.chipnum = Byte.parseByte(v1[iChipNumCN]);

						/*
						 * if (paired) { // 1.1 paired if (iLog2RatioMin >= 0)
						 * record.log2ratiomin = parse(v1[iLog2RatioMin]); if
						 * (iLog2RatioMax >= 0) record.log2ratiomax =
						 * parse(v1[iLog2RatioMax]); if (iHmmMedianLog2RatioMin >=
						 * 0) record.hmmmedianlog2ratiomin =
						 * parse(v1[iHmmMedianLog2RatioMin]); if
						 * (iHmmMedianLog2RatioMax >= 0)
						 * record.hmmmedianlog2ratiomax =
						 * parse(v1[iHmmMedianLog2RatioMax]); if
						 * (iNegLog10PValueMin >= 0) record.neglog10pvaluemin =
						 * parse(v1[iNegLog10PValueMin]); if (iNegLog10PValueMax >=
						 * 0) record.neglog10pvaluemax =
						 * parse(v1[iNegLog10PValueMax]); if (iCNStateMin >= 0)
						 * record.cnstatemin = parse(v1[iCNStateMin]); if
						 * (iCNStateMax >= 0) record.cnstatemax =
						 * parse(v1[iCNStateMax]); }
						 */
					}
					if (state == State.SINGLE_LOH || state == State.BOTH || state==State.FINISH_LOH) {
						// 1.1 LOH
						record.probeSet = probeSetLOH;
						record.locus = locLOH;
						// if (iCall >= 0)
						// record.call = v2[iCall].toCharArray();
						if (iRefHetRate >= 0)
							record.refHetRate = Float.parseFloat(v2[iRefHetRate]);
						if (iLohState >= 0)
							record.lohState = Byte.parseByte(v2[iLohState]);
						if (iLohProb >= 0)
							record.lohProb = Float.parseFloat(v2[iLohProb]);
						if (iRetProb >= 0)
							record.retProb = Float.parseFloat(v2[iRetProb]);
						if (iChipNumLOH >= 0)
							record.chipnum = Byte.parseByte(v2[iChipNumLOH]);

					}
				
					
			} catch (NumberFormatException e) {
				MainApp.getLogger().throwing(getClass().getName(),"readElements", e);
				throw new FileFormatException(
						"CNT file format error at line "
								+ inCN.getLineNumber()
								+ " illegal field value");
			} catch (Exception e) {
				MainApp.getLogger().throwing(getClass().getName(),"readElements", e);
				throw new FileFormatException(
						"Exception while parsing CNT file entry at line "
								+ inCN.getLineNumber() + "NEWLINE"
								+ e.getLocalizedMessage());
			}

			if (record.locus.chromosome > 0) { 		// more validity checks
													// here??
				data.add(record);
			}

				/*
				 * if (notifier != null) { // notify progress indicator int
				 * line_number = inCN.getLineNumber(); if (line_number % 100 ==
				 * 0) { if (num_rows_CN > 0) { notifier.setText("import "+
				 * Math.round((100.0 * (double) line_number / num_rows_CN)) +
				 * "%"); } else { notifier.setText("import " + (line_number /
				 * 1000) + "k"); } } }
				 */
		}
	}
    
	/*private float parse(String s) {
		if(s.equals("null")) return Float.NaN;
		else return Float.parseFloat(s);
		
	}*/

	/**
	 * Finds the index of the given field.
	 * 
	 * @param col A FieldName to FieldIndex map
	 * @param field
	 * @return -1 If the field was not found
	 */
	protected byte getFieldIndex(Map<String, Integer> col, Fields field)
	{
		Integer i = col.get(field.name());
		if( i == null ) {
			return -1;
		}
		return i.byteValue();
	}

	public LinkedList<String> getFileName() {
		LinkedList<String> l = new LinkedList<String>();
		
		if( CNFile != null ) {
			l.add(CNFile.getAbsolutePath());
		}
		
		if( LOHFile != null) {
			l.add(LOHFile.getAbsolutePath());		
		}
		return l;
	}
	
	public TreeSet<AffyCntRecord> getData()
	{
		validate();
		return data;
	}
	
	public AffyCntRecord getRecord(int idx)
	{
		validate();
		return cache[idx];
	}
	
	public String getMarkerName(int idx)
	{
		return getRecord(idx).probeSet;
	}

	public Byte getChromosome(int idx)
	{
		return getRecord(idx).locus.chromosome;
	}
	
	public Interval getInterval(int idx)
	{
		return getRecord(idx).locus.interval;
	}
	
	/**
	 * Returns a field value given a field name (as enum).
	 * @param field
	 * @param idx
	 * @return
	 */
	public float getValue(AllParameters.FieldA field, int idx) {
		AffyCntRecord rec = getRecord(idx);

		if (field == AllParameters.FieldA.LOGRATIO)	return rec.log2ratio;
		if (field == AllParameters.FieldA.LOH ) return rec.loh;
		if (field == AllParameters.FieldA.GSA ) return rec.gsa_cn;
		if (field == AllParameters.FieldA.SPA ) return rec.spa_cn;
		if (field == AllParameters.FieldA.GSA_P ) return rec.gsa_pval;
		if (field == AllParameters.FieldA.SPA_P ) return rec.spa_pval;
		
		throw new IllegalArgumentException();

	}
	
	/**
	 * Returns a field value given a field name (as enum).
	 * @param field
	 * @param idx
	 * @return
	 */
	public float getValue(AllParameters.FieldB field, int idx) {
		AffyCntRecord rec = getRecord(idx);
		
		if (field == AllParameters.FieldB.LOGRATIO)			return rec.log2ratio;
		if (field == AllParameters.FieldB.HMMMEDIANLOG2RATIO) return rec.hmmmedianlog2ratio;
		if (field == AllParameters.FieldB.NEGLOG10PVALUE) return rec.neglog10pvalue;
		//if (field == AllParameters.FieldB.CNSTATE) return rec.cnstate;
		
		//paired
		/*if (field == AllParameters.Field.HMMMEDIANLOG2RATIOMIN) return rec.hmmmedianlog2ratiomin;
		if (field == AllParameters.Field.HMMMEDIANLOG2RATIOMAX) return rec.hmmmedianlog2ratiomax;
		if (field == AllParameters.Field.CNSTATEMIN) return rec.cnstatemin;
		if (field == AllParameters.Field.CNSTATEMAX) return rec.cnstatemax;
		if (field == AllParameters.Field.NEGLOG10PVALUEMIN) return rec.neglog10pvaluemin;
		if (field == AllParameters.Field.NEGLOG10PVALUEMAX) return rec.neglog10pvaluemax;
		if (field == AllParameters.Field.LOG2RATIOMIN) return rec.log2ratiomin;
		if (field == AllParameters.Field.LOG2RATIOMAX) return rec.log2ratiomax;*/
		
		// LOH
		//if (field == AllParameters.FieldB.CALL) return Float.NaN;
		if (field == AllParameters.FieldB.REFHETRATE) return rec.refHetRate;
		if (field == AllParameters.FieldB.LOHSTATE) return rec.lohState;
		if (field == AllParameters.FieldB.LOHPROB) return rec.lohProb;
		if (field == AllParameters.FieldB.RETPROB) return rec.retProb;
	
		throw new IllegalArgumentException();
	}
	
	/*public void show()
	{
		// print summary
		for(int i=0; i<getNumMarkers(); ++i )
		{
			System.out.println("RECORD "+i+"\n");
			System.out.println(getRecord(i).toString());
		}
	}*/
		
	public int getNumMarkers()
	{
		return data.size();
	}
	
	
	/**
	 * Merges the other data model into the current.
	 * 
	 * @param other
	 */
	/*
	public void mergeWithDataModel( AffymetrixCntReaderModel other )
	{
		data.addAll( other.getData() );
		
		invalidate();
		fireChangeEvent();
	}
	*/
	
	public void validate()
	{
		if( !valid )
		{
			updateCache();
			updateIntervals();
			valid = true;
		}
	}
	
	public void invalidate()
	{
		valid = false;
	}
	
	protected void updateCache()
	{
		if( data == null )
		{
			cache = null;
			return;
		}
		if( (cache == null) || (cache.length != data.size()) )
		{
			cache = new AffyCntRecord[data.size()];
		}
		data.toArray(cache);
	}
	
	/**
	 * Updates the interval lengths (Field AffyCntRecord.Interval). 
	 *
	 * Requires: cache has to be valid (see {@link #updateCache()}).
	 */
	protected void updateIntervals()
	{
		for( int i=0; i<cache.length; ++i )
		{
			if( (i+1<cache.length) && (cache[i+1].locus.chromosome == cache[i].locus.chromosome) )
			{
				cache[i].locus.interval.to = cache[i+1].locus.interval.from-1;
			}
			else
			{	// last interval
				cache[i].locus.interval.to = cache[i].locus.interval.from + 20; // TODO put 20 in constant
			}					
		}
	}

	/*public double[] getAllValues( AllParameters.Field field ) 
	{
		double[] a = new double[data.size()];
		
		for(int i=0; i<data.size(); ++i )
		{
			a[i] = getValue(field, i);
		}
		
		return a;
	}*/

	public FileVersion getVersion() {
		return version;
	}

	public LinkedList<String> getHeader() {
		LinkedList<String> l = new LinkedList<String>();
		StringBuffer buf = new StringBuffer();
		Iterator it = header.keySet().iterator();
		while(it.hasNext()) {
			Object next = it.next();
			buf.append(next+"\t");
			buf.append(header.get(next));
			if(it.hasNext()) buf.append("\n");
		}
		l.add(buf.toString());
		if (headerLOH != null) {
			buf = new StringBuffer();
			Iterator it2 = headerLOH.keySet().iterator();
			while (it2.hasNext()) {
				Object next = it2.next();
				buf.append(next + "\t");
				buf.append(headerLOH.get(next));
				if (it2.hasNext()) buf.append("\n");
			}
			l.add(buf.toString());
		}
		return l;	
	}

	public LinkedList<String> getChipType() {
		LinkedList<String> l = new LinkedList<String>();
		l.add(header.get("ChipType1"));
		if(headerLOH != null) {
			l.add(headerLOH.get("ChipType1"));
		}
		return l;
	}

}
